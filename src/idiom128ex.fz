ex128 is

  node(name string, children List<node>) is

  BreadthFirstTraverse(f node -> unit, root node) =>
    _BreadthFirstTraverse(queue List<node>) unit is
      match queue.asList
        nil =>
        c Cons =>
          f c.head
          _BreadthFirstTraverse (c.tail ++ c.head.children)
    _BreadthFirstTraverse [root].asList

  # World
  # ├─Europe
  # │ ├─Belarous
  # │ ├─Portugal
  # ├─Asia
  # ├─Oceania
  # NYI type inference: [] should work for Lists.empty<node>
  five := node "Belarus" Lists.empty<node>
  six := node "Portugal" Lists.empty<node>
  two := node "Europe" [five, six]
  three := node "Asia" Lists.empty<node>
  four := node "Oceania" Lists.empty<node>
  one := node "World" [two, three, four]

  BreadthFirstTraverse (node -> say node.name) one
